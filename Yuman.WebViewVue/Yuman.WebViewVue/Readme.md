# 系统搭建流程
## 1.WebView2（WinForm程序）
NuGet包引入WebView2，将WebView2控件挂到Form1，然后建立index.html，WebView2来源指定这个静态页面

## 2.引入平时开发常用的类库、组件
建立_lib、_pages文件夹，将常用的组件类库加入进来，并在index.html页面引入

## 3.封装导航栏和分页加载
引入handlebars.js，将页面渲染参数配置化，然后其他分页通过后端读取本地文件的方式，用字符串返回给前端进行动态拼接；
每个分页单独初始化vue，切换菜单时就进行初始化操作

## 4.引入依赖注入，实现动态反射注入
引入Microsoft.Extensions.DependencyInjection类库，对窗体应用实现依赖注入，建立3种接口，瞬态/作用域/单例，分别对继续了这3种接口的实现对应注入

## 5.封装一套前后端请求，符合ajax的使用习惯
5.1.最开始是使用WebView2自带的PostMessage的方式，前端发消息后端接收，后端发消息前端接口的方式，然后发现这种方式要自己实现回调等待一系列问题，可以实现但是太麻烦
5.2.接着是了解到WebView2有HostObjects的通讯方式，不过发现这种方式后端接口传入和传出都是字符串比较好用，如果是复杂类型就很难用
5.3.在5.2的基础上后端所有的接口都按照传入传出都是字符串的类型，然后每个方法里面自己去序列化和反序列化，但是这样太麻烦了
5.4.在5.2和5.3的基础上再优化，固定一个HostObjects接口，传入传出都是字符串类型，然后自己反射需要提供接口的类，然后固定生成一套js给前端调用，然后后端接口方法也使用反射去实例化方法执行
最终实现了一套整齐的接口调用，符合传统的ajax的调用习惯

## 6.将前端的html、css、js改成嵌入资源文件，不要生成到本地文件，容易丢失或被篡改
6.1.建立一个wwwroot文件，将原来的_lib、_pages和index相关文件都挪进去，然后设置这个wwwroot是嵌入资源
6.2.WebView2初始化的时候，创建一个Web资源请求拦截器，拦截指定的域名，然后实现监听
6.3.html页面的script和link的地址改为指定域名
6.4.监听里面实现去嵌入资源读取并返回（这里特别注意一点：嵌入资源文件命名空间中，也就是文件夹中含有“ - ”将被转为“ _ ”，即短杠转成了下划线，所以读取资源文件的时候也转换一下）
6.5.其他读取本地文件的地方也改成读取嵌入资源（例如：读取分页html）

## 7.支持多语言
7.1.建立翻译文件，用json格式，然后建立静态类，统一封装读取json，并提供翻译方法
7.2.WebView2初始化的时候也加载进入前端，也封装一个统一L方法提供翻译
7.3.Services和Manager层提供一个基类，里面提供统一L方法，全部Services和Manager的类继续该基类就可以用L方法了


# 后续正常开发流程
## 1.在index.js里面配菜单名称
## 2.在pages创建页面、js、css
## 3.在index.html引入js和css，记得按统一域名（http://embedded.res就相当于wwwroot）
## 4.在Services实现后端接口
## 5.在Managers实现业务逻辑，给接口调用


# 开发注意的一些原则
## 1.链接数据库等底层操作，只在Managers里面进行，Services只对外开发接口，不要在这里依赖数据库查询，以后可能更换数据库，只需要重写Manager服务即可


# 后续框架升级
## 1.TODO...


# 项目结构
## 1.wwwroot是前端相关文件
## 2.Services是后端接口，将实体转dto，对前端开放接口
## 3.Managers是后端服务，核心业务逻辑
## 4.Hepler是帮助类


# 辅助功能
## 1.标记MyRequired特性，支持前端传入参数自动校验必填


# 额外遇到的问题与解决方案
1.读取html文件中文乱码，引入System.Text.Encoding.CodePages包，注册并使用GB2312读取文件即可